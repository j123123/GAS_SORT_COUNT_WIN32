.intel_syntax noprefix

.section .data

# Несортированный массив
ARRAY:
    .byte   2,   1,  0,    3,   8 
    .byte  16,  82,  23,  66,   0
    .byte  17,  16,  74,   3,   6
    .byte    1,   3,  55,  16,  17
    .byte  33, 133, 254, 241,   5
# Размер массива, находится как число разницы адресов начала и конца

    ARR_SIZE= . - ARRAY


/*---------------------------------------
Массив, сортированный другими средствами|
    .byte    0,   0,   1,   1,   2      |
    .byte    3,   3,   3,   5,   6      |
    .byte     8,  16,  16,  16,  17     |
    .byte    17,  23,  33,  55,  66     |
    .byte    74,  82, 133, 241, 254     |
---------------------------------------*/

# Выделение памяти под массив подсчета
TMP_ARR:  
    .space 256

# Хранение адреса стека возле адреса возврата
RET_ADDR:
    .space 4

# Выделение памяти под преобразованный в текст массив
_tmp:
    .space ARR_SIZE*4+1

# Выделение памяти под формат преобразования
format_str:
    .rept ARR_SIZE
        .ascii "%u "
    .endr
        .ascii "\0"

# Строка с заголовком окна программы
_title:
    .ascii "Counting sort\0"

    .section .text

    .globl _WinMainCRTStartup
_WinMainCRTStartup:

    MOV DWORD PTR DS:[RET_ADDR], ESP # Сохраняем адрес стека возле возврата

################# Начало алгоритма сортировки #################
    
    MOV EAX, 0                            # Регистр для хранеия элемента несорт массива, ис-ся как указатель
    MOV EBX, 0                            # Счетчик прохода по массиву TMP_ARR
    MOV ECX, 0                            # Счетчик прохода по массиву ARRAY

repeatOne:
    MOV AL, BYTE PTR DS:[ARRAY + ECX]     # Помещаем эл-нт массива в регистр
    INC ECX                               # Увеличиваем счетчик прохода
    MOV BL, BYTE PTR DS:[TMP_ARR + EAX]   # Помещаем элемент-счетчик номером EAX в регистр
    INC BL                                # Увеличиваем его
    MOV BYTE PTR DS:[TMP_ARR + EAX], BL   # Помещаем обратно в массив-счетчик    
    CMP ECX, ARR_SIZE                     # Сравниваем показатель счетчика с размером массива
    JNE repeatOne                         # Если не равны проходим еще раз, в ином случае идем дальше




    MOV EAX, 0x0                          # Счетчик прохода массива TMP_ARR
    MOV EBX, 0x0                          # Счетчик прохода массива ARRAY
    MOV ECX, 0x0                          # То, сколько элементов с таким "номером"
#    MOV EDX, 0x0                          # Просто нуль
        
    JMP ENTRY
repeatTwo:
    INC AL                                # Увеличиваем счетчик-указатель количества чисел
    CMP AL, 0x0                           # Сравнение указателя с нулем. После 255 идет 0
    JE  toExit                            # Если нуль то идем к выходу
ENTRY:
    MOV CL, BYTE PTR DS:[TMP_ARR + EAX]   # Читаем из подсчитывающего массива кол-во "номеров"
    CMP CL, 0x0                           # TEST CL, CL А не нуль ли их?
WHILE_BL_NOT_ZERO:
    JZ    repeatTwo                       # Если ноль, надо переходить к следующему элементу
    MOV BYTE PTR DS:[ARRAY + EBX], AL     # Пишем элемент в массив ARRAY
    INC BX                                # Переходим на след. элемент в массиве ARRAY
    DEC CL                                # Уменьшаем счетчик элементов с таким "номером"
    JMP WHILE_BL_NOT_ZERO                 # Если нуль, то переходим к следующему "номеру"
    
################# Конец алгоритма сортировки #################
    
toExit:

################# Начало алгоритма перевода байтиков в стек #################

# Преобразование массива в строку
# Помещаем каждое число из массива с конца в стек
    MOV EAX, ARR_SIZE-1
    MOV EBX, 0x0

    .rept ARR_SIZE                        # Этот макрос просто повторит(накопипастит) этот кусок много раз
        MOV BL, BYTE PTR DS:[ARRAY+EAX]
        DEC EAX
        PUSH EBX
    .endr                                 # Намного лучше можно было сделать это все


    
# Вызов ф-ции перевода в строку
    PUSH OFFSET FLAT:format_str
    PUSH OFFSET FLAT:_tmp
    CALL _sprintf
    
# Вывод массива в диалоговом окне
    PUSH   0x0                            # style
    PUSH   OFFSET FLAT:_title             # Указатель на заголовок
    PUSH   OFFSET FLAT:_tmp               # Указатель на строку с отсотрированными числами в виде текста  
    PUSH   0x0                            # window handle
    CALL  _MessageBoxA@16                 # MessageBox

# Т.к. стек засорился, то возвращаем указатель на стек возле адреса возврата
    MOV ESP, DWORD PTR DS:[RET_ADDR] 

# Заносим в регистр 0, как удачное завершение программы и выходим из функции WinMainCRTStartup
    MOV  EAX, 0
    RET 16
